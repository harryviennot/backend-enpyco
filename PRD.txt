
# PRD Backend - Application de Génération de Mémoires Techniques

## 1. Vue d'ensemble

### Objectif
Fournir une API REST robuste et performante pour la génération automatisée de mémoires techniques, avec capacités de RAG, parsing de documents, et génération via LLM.

### Stack technique
- **Runtime**: Node.js 20 (Next.js API Routes)
- **ORM**: Prisma
- **Base de données**: PostgreSQL 15 + pgvector -> Supabase
- **Stockage**: AWS S3 (ou compatible) -> Supabase buckets
- **IA**: Anthropic Claude API (Sonnet 4.5)
- **Embeddings**: OpenAI text-embedding-3-small
- **Queue**: BullMQ + Redis
- **Python services**: FastAPI (parsing, generation)

---

## 2. Architecture Backend

### Structure de services

```
backend/
├── api/                    # Next.js API routes
│   ├── projects/
│   ├── documents/
│   ├── blocks/
│   ├── generation/
│   └── export/
├── services/
│   ├── rag/               # RAG service
│   ├── ai/                # Claude integration
│   ├── parser/            # Document parsing
│   ├── storage/           # S3 operations
│   ├── template/          # Word templates
│   └── queue/             # Job queue
├── lib/
│   ├── prisma/
│   ├── validators/        # Zod schemas
│   └── utils/
└── python/                # Python microservices
    ├── parser/            # PDF/Word parsing
    ├── exporter/          # Word generation
    └── embeddings/        # Vector operations
```

---

## 3. API Endpoints

### 3.1 Authentification

```typescript
POST /api/auth/register
POST /api/auth/login
POST /api/auth/logout
GET  /api/auth/me
```

**Body (register/login):**
```json
{
  "email": "user@example.com",
  "password": "securePassword123",
  "name": "Pierre Durand"
}
```

---

### 3.2 Projets

#### Créer un projet
```typescript
POST /api/projects
```

**Body:**
```json
{
  "name": "Bande Infra SNCF",
  "client": "SNCF Réseau",
  "description": "Construction de bande d'infrastructure ferroviaire"
}
```

**Response:**
```json
{
  "id": "uuid",
  "name": "Bande Infra SNCF",
  "status": "DRAFT",
  "createdAt": "2025-01-15T10:00:00Z"
}
```

#### Lister les projets
```typescript
GET /api/projects?status=DRAFT&limit=20&offset=0
```

**Query params:**
- `status`: DRAFT | GENERATING | READY | FINAL | ARCHIVED
- `limit`: number (default: 20)
- `offset`: number (default: 0)
- `search`: string
- `sort`: createdAt | updatedAt | name (default: updatedAt)
- `order`: asc | desc (default: desc)

#### Obtenir un projet
```typescript
GET /api/projects/:id
```

**Response:**
```json
{
  "id": "uuid",
  "name": "Bande Infra SNCF",
  "client": "SNCF Réseau",
  "status": "DRAFT",
  "rcFileUrl": "https://...",
  "rcCriteria": ["critère 1", "critère 2"],
  "selectedMemoires": ["uuid1", "uuid2"],
  "sectionsConfig": {...},
  "createdAt": "2025-01-15T10:00:00Z",
  "updatedAt": "2025-01-15T11:30:00Z"
}
```

#### Mettre à jour un projet
```typescript
PATCH /api/projects/:id
```

**Body (partiel):**
```json
{
  "name": "Nouveau nom",
  "selectedMemoires": ["uuid1", "uuid2", "uuid3"],
  "sectionsConfig": {...}
}
```

#### Supprimer un projet
```typescript
DELETE /api/projects/:id
```

---

### 3.3 Documents

#### Upload du RC
```typescript
POST /api/projects/:projectId/documents/rc
Content-Type: multipart/form-data
```

**Body:**
- `file`: PDF file

**Response:**
```json
{
  "id": "uuid",
  "projectId": "uuid",
  "type": "RC",
  "fileUrl": "https://s3.../rc.pdf",
  "fileName": "rc_bande_infra.pdf",
  "fileSize": 2048576,
  "status": "parsing",
  "jobId": "job-uuid"
}
```

#### Statut du parsing
```typescript
GET /api/projects/:projectId/documents/:documentId/status
```

**Response:**
```json
{
  "status": "done",
  "extractedCriteria": [
    "Présentation de l'entreprise",
    "Organisation du chantier",
    "Planning prévisionnel"
  ],
  "metadata": {
    "pageCount": 45,
    "extractedText": "...",
    "parsingTime": 12.5
  }
}
```

#### Upload d'autres documents
```typescript
POST /api/projects/:projectId/documents
Content-Type: multipart/form-data
```

**Body:**
- `file`: File
- `type`: PLANNING | PIC | ORGANIGRAMME | PHOTO | AUTRE

---

### 3.4 Mémoires de référence

#### Lister les mémoires
```typescript
GET /api/reference-memoires?type=logement&year=2024
```

**Query params:**
- `type`: string (type de projet)
- `year`: number
- `client`: string
- `indexed`: boolean
- `limit`, `offset`, `search`

**Response:**
```json
{
  "data": [
    {
      "id": "uuid",
      "name": "Mémoire Résidence Les Érables",
      "client": "Toulouse Métropole Habitat",
      "year": 2024,
      "projectType": "logement",
      "indexed": true,
      "chunkCount": 245,
      "createdAt": "2024-11-01T00:00:00Z"
    }
  ],
  "total": 15,
  "limit": 20,
  "offset": 0
}
```

#### Upload d'un mémoire
```typescript
POST /api/reference-memoires
Content-Type: multipart/form-data
```

**Body:**
- `file`: PDF or DOCX
- `name`: string
- `client`: string (optional)
- `year`: number (optional)
- `projectType`: string (optional)
- `location`: string (optional)
- `montant`: number (optional)
- `autoIndex`: boolean (default: true)

**Response:**
```json
{
  "id": "uuid",
  "name": "Mémoire Résidence Les Érables",
  "fileUrl": "https://...",
  "indexed": false,
  "indexJobId": "job-uuid"
}
```

#### Indexer un mémoire
```typescript
POST /api/reference-memoires/:id/index
```

**Response:**
```json
{
  "jobId": "job-uuid",
  "status": "queued"
}
```

#### Statut d'indexation
```typescript
GET /api/reference-memoires/:id/index/status
```

**Response:**
```json
{
  "status": "processing",
  "progress": 65,
  "chunksProcessed": 160,
  "totalChunks": 245,
  "estimatedTimeRemaining": 45
}
```

#### Suggérer des mémoires similaires
```typescript
POST /api/reference-memoires/suggest
```

**Body:**
```json
{
  "rcText": "Contenu du RC...",
  "limit": 5
}
```

**Response:**
```json
{
  "suggestions": [
    {
      "id": "uuid",
      "name": "Mémoire Résidence Les Érables",
      "similarityScore": 0.87,
      "matchedCriteria": ["organisation chantier", "planning"]
    }
  ]
}
```

---

### 3.5 Blocs de contenu

#### Lister les blocs
```typescript
GET /api/blocks?type=ORGANIGRAMME_GROUPE&category=presentation
```

**Query params:**
- `type`: BlockType
- `category`: string
- `tags`: string[] (comma-separated)
- `isTemplate`: boolean

#### Créer un bloc
```typescript
POST /api/blocks
```

**Body:**
```json
{
  "type": "PRESENTATION_ENTREPRISE",
  "title": "Présentation Groupe Bernadet",
  "content": "# Groupe Bernadet\n\n...",
  "images": ["https://..."],
  "category": "presentation",
  "tags": ["bernadet", "rse"],
  "isTemplate": true
}
```

#### Mettre à jour un bloc
```typescript
PATCH /api/blocks/:id
```

#### Supprimer un bloc
```typescript
DELETE /api/blocks/:id
```

---

### 3.6 Génération

#### Générer un mémoire complet
```typescript
POST /api/projects/:projectId/generate
```

**Body:**
```json
{
  "selectedMemoires": ["uuid1", "uuid2"],
  "sectionsConfig": [
    {
      "type": "PRESENTATION_ENTREPRISE",
      "enabled": true,
      "order": 1,
      "customInstructions": "Mettre l'accent sur l'expérience RSE"
    },
    {
      "type": "ORGANISATION_CHANTIER",
      "enabled": true,
      "order": 2
    }
  ],
  "globalInstructions": "Ton professionnel mais accessible"
}
```

**Response:**
```json
{
  "jobId": "job-uuid",
  "status": "queued",
  "estimatedDuration": 180
}
```

#### Statut de génération
```typescript
GET /api/projects/:projectId/generate/status
```

**Response (en cours):**
```json
{
  "status": "processing",
  "currentSection": "METHODOLOGIE",
  "completed": 4,
  "total": 10,
  "progress": 40,
  "estimatedTimeRemaining": 120
}
```

**Response (terminé):**
```json
{
  "status": "done",
  "sections": [
    {
      "id": "uuid",
      "type": "PRESENTATION_ENTREPRISE",
      "title": "Présentation de l'entreprise",
      "status": "GENERATED"
    }
  ],
  "totalTokens": 15420,
  "generationTime": 145
}
```

#### Régénérer une section
```typescript
POST /api/sections/:sectionId/regenerate
```

**Body:**
```json
{
  "instruction": "Rendre plus concis",
  "keepImages": true,
  "context": {
    "additionalInfo": "Mentionner l'expérience sur projets SNCF"
  }
}
```

**Response:**
```json
{
  "jobId": "job-uuid",
  "status": "queued"
}
```

#### Obtenir une section
```typescript
GET /api/sections/:id
```

**Response:**
```json
{
  "id": "uuid",
  "projectId": "uuid",
  "type": "PRESENTATION_ENTREPRISE",
  "title": "Présentation de l'entreprise",
  "content": "# Groupe Bernadet\n\n...",
  "images": ["https://..."],
  "version": 2,
  "status": "VALIDATED",
  "tokensUsed": 1250,
  "generationTime": 8.5,
  "context": {...},
  "createdAt": "2025-01-15T14:30:00Z"
}
```

#### Valider une section
```typescript
POST /api/sections/:id/validate
```

**Response:**
```json
{
  "id": "uuid",
  "status": "VALIDATED",
  "validatedAt": "2025-01-15T15:00:00Z"
}
```

#### Comparer les versions
```typescript
GET /api/sections/:id/versions/:versionNumber/diff
```

**Response:**
```json
{
  "oldVersion": {
    "version": 1,
    "content": "...",
    "createdAt": "..."
  },
  "newVersion": {
    "version": 2,
    "content": "...",
    "createdAt": "..."
  },
  "diff": {
    "added": ["nouveau paragraphe..."],
    "removed": ["ancien texte..."],
    "modified": [...]
  }
}
```

---

### 3.7 Export

#### Exporter le mémoire final
```typescript
POST /api/projects/:projectId/export
```

**Body:**
```json
{
  "format": "docx",
  "options": {
    "includePageNumbers": true,
    "includeTOC": true,
    "includeHeaders": true,
    "includeFooters": true,
    "customCoverPage": false
  }
}
```

**Response:**
```json
{
  "jobId": "job-uuid",
  "status": "queued",
  "estimatedDuration": 30
}
```

#### Statut de l'export
```typescript
GET /api/projects/:projectId/export/status
```

**Response (terminé):**
```json
{
  "status": "done",
  "fileUrl": "https://s3.../memoire_final.docx",
  "fileName": "memoire_bande_infra_sncf.docx",
  "fileSize": 5242880,
  "exportTime": 25
}
```

#### Télécharger le mémoire
```typescript
GET /api/projects/:projectId/download
```

**Response:** Fichier DOCX en téléchargement direct

---

### 3.8 Templates

#### Lister les templates
```typescript
GET /api/templates
```

**Response:**
```json
{
  "data": [
    {
      "id": "uuid",
      "name": "Template Bernadet RSE",
      "type": "MEMOIRE_COMPLET",
      "version": "2.0",
      "isDefault": true,
      "thumbnailUrl": "https://...",
      "downloadUrl": "https://..."
    }
  ]
}
```

#### Upload d'un template
```typescript
POST /api/templates
Content-Type: multipart/form-data
```

**Body:**
- `file`: DOCX file
- `name`: string
- `type`: MEMOIRE_COMPLET | SECTION | PAGE_GARDE
- `isDefault`: boolean

---

### 3.9 Assets

#### Lister les assets
```typescript
GET /api/assets?type=IMAGE&category=organigramme
```

#### Upload d'un asset
```typescript
POST /api/assets
Content-Type: multipart/form-data
```

**Body:**
- `file`: Image file
- `type`: IMAGE | LOGO | ICON
- `category`: string
- `title`: string
- `tags`: string[]

---

## 4. Services Backend

### 4.1 RAG Service

**Fichier:** `services/rag/rag.service.ts`

#### Fonctions principales

```typescript
class RAGService {
  // Indexer un mémoire
  async indexMemoire(memoireId: string): Promise<void> {
    // 1. Récupérer le document
    // 2. Parser le contenu (appel Python service)
    // 3. Chunking intelligent
    // 4. Générer embeddings
    // 5. Stocker dans pgvector
  }

  // Rechercher des chunks pertinents
  async searchRelevantChunks(
    query: string,
    memoireIds: string[],
    limit: number = 20
  ): Promise<DocumentChunk[]> {
    // 1. Générer embedding du query
    // 2. Recherche par similarité dans pgvector
    // 3. Filter par memoireIds
    // 4. Retourner top K chunks
  }

  // Suggérer des mémoires similaires
  async suggestSimilarMemoires(
    rcText: string,
    limit: number = 5
  ): Promise<SimilarMemoire[]> {
    // 1. Extraire critères clés du RC
    // 2. Générer embedding
    // 3. Recherche par similarité
    // 4. Scorer et trier
  }
}
```

#### Algorithme de chunking

```typescript
interface ChunkingStrategy {
  method: 'semantic' | 'fixed' | 'hybrid'
  maxTokens: number
  overlap: number // tokens
  preserveStructure: boolean
}

async function chunkDocument(
  text: string,
  strategy: ChunkingStrategy
): Promise<Chunk[]> {
  // Semantic: découpe par sections (H1, H2)
  // Fixed: découpe tous les N tokens
  // Hybrid: sections + limite de tokens
}
```

---

### 4.2 AI Service (Claude)

**Fichier:** `services/ai/claude.service.ts`

```typescript
class ClaudeService {
  private client: Anthropic

  // Générer une section
  async generateSection(
    sectionType: BlockType,
    context: {
      rcCriteria: string[]
      relevantChunks: DocumentChunk[]
      userInstructions?: string
      previousVersion?: string
    }
  ): Promise<{
    content: string
    tokensUsed: number
    generationTime: number
  }> {
    const prompt = this.buildPrompt(sectionType, context)
    
    const response = await this.client.messages.create({
      model: 'claude-sonnet-4-5-20250929',
      max_tokens: 4096,
      temperature: 0.7,
      messages: [{ role: 'user', content: prompt }]
    })

    return {
      content: response.content[0].text,
      tokensUsed: response.usage.input_tokens + response.usage.output_tokens,
      generationTime: Date.now() - startTime
    }
  }

  // Construire le prompt
  private buildPrompt(
    sectionType: BlockType,
    context: Context
  ): string {
    return `
Tu es un expert en rédaction de mémoires techniques pour le BTP.

**Contexte du projet :**
- Type de section : ${sectionType}
- Critères du RC : ${context.rcCriteria.join(', ')}

**Contenu de référence :**
${context.relevantChunks.map(c => c.content).join('\n\n---\n\n')}

${context.previousVersion ? `
**Version précédente :**
${context.previousVersion}

**Instruction d'amélioration :**
${context.userInstructions}
` : ''}

**Instructions :**
- Génère un contenu professionnel mais accessible
- Utilise des tableaux plutôt que des listes
- Conserve les éléments factuels des références
- Adapte au contexte du RC
- Format : Markdown

**Contraintes :**
- Maximum 1500 mots
- Ton neutre et professionnel
- Pas de jargon excessif
    `.trim()
  }

  // Extraire critères du RC
  async extractRCCriteria(rcText: string): Promise<string[]> {
    const prompt = `
Extrait les critères d'évaluation du mémoire technique depuis ce RC :

${rcText}

Liste uniquement les critères (1 par ligne).
    `
    // ...
  }
}
```

---

### 4.3 Document Parser Service

**Python microservice:** `python/parser/main.py`

```python
from fastapi import FastAPI, UploadFile
from pypdf import PdfReader
from docx import Document
import re

app = FastAPI()

@app.post("/parse/pdf")
async def parse_pdf(file: UploadFile):
    """Parse un PDF et retourne le texte structuré"""
    reader = PdfReader(file.file)
    
    sections = []
    current_section = None
    
    for page in reader.pages:
        text = page.extract_text()
        
        # Détecter les titres (heuristiques)
        lines = text.split('\n')
        for line in lines:
            if is_heading(line):
                if current_section:
                    sections.append(current_section)
                current_section = {
                    'title': line,
                    'content': ''
                }
            elif current_section:
                current_section['content'] += line + '\n'
    
    return {
        'sections': sections,
        'metadata': {
            'page_count': len(reader.pages),
            'total_chars': len(text)
        }
    }

@app.post("/parse/docx")
async def parse_docx(file: UploadFile):
    """Parse un DOCX et retourne le texte + images"""
    doc = Document(file.file)
    
    sections = []
    images = []
    
    for para in doc.paragraphs:
        if para.style.name.startswith('Heading'):
            sections.append({
                'title': para.text,
                'level': int(para.style.name[-1]),
                'content': ''
            })
        else:
            if sections:
                sections[-1]['content'] += para.text + '\n'
    
    # Extraire images
    for rel in doc.part.rels.values():
        if "image" in rel.target_ref:
            images.append({
                'data': rel.target_part.blob,
                'type': rel.target_part.content_type
            })
    
    return {
        'sections': sections,
        'images': images,
        'metadata': {
            'paragraph_count': len(doc.paragraphs)
        }
    }

def is_heading(line: str) -> bool:
    """Détecter si une ligne est un titre"""
    # Heuristiques : majuscules, court, numérotation, etc.
    if len(line) > 100:
        return False
    if re.match(r'^\d+\.', line):  # Numérotation
        return True
    if line.isupper():  # Tout en majuscules
        return True
    return False
```

**API Wrapper (Node.js):**
```typescript
// services/parser/parser.service.ts

class ParserService {
  private pythonServiceUrl = process.env.PYTHON_SERVICE_URL

  async parsePDF(fileBuffer: Buffer): Promise<ParsedDocument> {
    const formData = new FormData()
    formData.append('file', new Blob([fileBuffer]), 'document.pdf')

    const response = await fetch(`${this.pythonServiceUrl}/parse/pdf`, {
      method: 'POST',
      body: formData
    })

    return response.json()
  }

  async parseDOCX(fileBuffer: Buffer): Promise<ParsedDocument> {
    // Similar
  }
}
```

---

### 4.4 Storage Service (S3)

**Fichier:** `services/storage/storage.service.ts`

```typescript
import { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3'
import { getSignedUrl } from '@aws-sdk/s3-request-presigner'

class StorageService {
  private s3: S3Client
  private bucket = process.env.S3_BUCKET!

  async uploadFile(
    file: Buffer,
    path: string,
    contentType: string
  ): Promise<string> {
    const key = `${path}/${Date.now()}-${Math.random().toString(36).slice(2)}`
    
    await this.s3.send(new PutObjectCommand({
      Bucket: this.bucket,
      Key: key,
      Body: file,
      ContentType: contentType
    }))

    return `https://${this.bucket}.s3.amazonaws.com/${key}`
  }

  async getSignedDownloadUrl(
    fileUrl: string,
    expiresIn: number = 3600
  ): Promise<string> {
    const key = this.extractKeyFromUrl(fileUrl)
    
    return getSignedUrl(
      this.s3,
      new GetObjectCommand({
        Bucket: this.bucket,
        Key: key
      }),
      { expiresIn }
    )
  }

  async deleteFile(fileUrl: string): Promise<void> {
    // ...
  }
}
```

---

### 4.5 Export Service

**Python microservice:** `python/exporter/main.py`

```python
from fastapi import FastAPI
from docx import Document
from docx.shared import Pt, RGBColor, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH
import markdown
from io import BytesIO

app = FastAPI()

@app.post("/export/docx")
async def export_to_docx(data: dict):
    """Convertit sections Markdown → DOCX stylé"""
    
    # Charger template
    doc = Document(data['template_path'])
    
    # Appliquer styles Bernadet
    apply_bernadet_styles(doc)
    
    # Ajouter sections
    for section in data['sections']:
        add_section_to_doc(
            doc,
            section['title'],
            section['content'],
            section['images']
        )
    
    # Sauvegarder
    buffer = BytesIO()
    doc.save(buffer)
    buffer.seek(0)
    
    return {
        'file': buffer.read(),
        'size': buffer.tell()
    }

def apply_bernadet_styles(doc):
    """Applique la charte graphique Bernadet"""
    # Heading 1
    h1 = doc.styles['Heading 1']
    h1.font.name = 'Montserrat'
    h1.font.size = Pt(18)
    h1.font.color.rgb = RGBColor(46, 80, 144)  # Bleu
    h1.font.bold = True
    
    # Heading 2
    h2 = doc.styles['Heading 2']
    h2.font.name = 'Montserrat'
    h2.font.size = Pt(14)
    h2.font.color.rgb = RGBColor(120, 180, 90)  # Vert
    
    # Normal
    normal = doc.styles['Normal']
    normal.font.name = 'Open Sans'
    normal.font.size = Pt(11)

def add_section_to_doc(doc, title, markdown_content, images):
    """Ajoute une section avec contenu Markdown"""
    
    # Titre de section
    doc.add_heading(title, level=1)
    
    # Parser Markdown
    html = markdown.markdown(markdown_content, extensions=['tables'])
    
    # Convertir HTML → paragraphes Word
    # (simplification, en réalité utiliser html2docx ou similaire)
    for para_text in parse_html_to_paragraphs(html):
        p = doc.add_paragraph(para_text)
        p.style = 'Normal'
    
    # Ajouter images
    for img_url in images:
        img_data = fetch_image(img_url)
        doc.add_picture(BytesIO(img_data), width=Inches(5))
    
    # Saut de page
    doc.add_page_break()
```

---

### 4.6 Queue Service (BullMQ)

**Fichier:** `services/queue/queue.service.ts`

```typescript
import { Queue, Worker } from 'bullmq'
import Redis from 'ioredis'

const connection = new Redis(process.env.REDIS_URL!)

// Queues
export const indexQueue = new Queue('indexing', { connection })
export const generationQueue = new Queue('generation', { connection })
export const exportQueue = new Queue('export', { connection })

// Workers

// Indexation de mémoire
new Worker('indexing', async (job) => {
  const { memoireId } = job.data
  
  await job.updateProgress(0)
  
  // 1. Parse document
  await job.updateProgress(20)
  
  // 2. Chunking
  await job.updateProgress(40)
  
  // 3. Generate embeddings
  await job.updateProgress(70)
  
  // 4. Store in DB
  await job.updateProgress(100)
  
  return { success: true, memoireId }
}, { connection })

// Génération de mémoire
new Worker('generation', async (job) => {
  const { projectId, sectionsConfig } = job.data
  
  const totalSections = sectionsConfig.length
  
  for (let i = 0; i < totalSections; i++) {
    const section = sectionsConfig[i]
    
    // Générer la section
    await generateSection(projectId, section)
    
    // Update progress
    await job.updateProgress((i + 1) / totalSections * 100)
  }
  
  return { success: true, projectId }
}, { connection, concurrency: 2 })

// Export de mémoire
new Worker('export', async (job) => {
  const { projectId, options } = job.data
  
  await job.updateProgress(0)
  
  // 1. Récupérer sections
  await job.updateProgress(20)
  
  // 2. Appel Python service
  await job.updateProgress(60)
  
  // 3. Upload S3
  await job.updateProgress(90)
  
  // 4. Save in DB
  await job.updateProgress(100)
  
  return { success: true, fileUrl: '...' }
}, { connection })
```

---

## 5. Validation & Sécurité

### 5.1 Validation (Zod)

```typescript
// lib/validators/project.validator.ts

import { z } from 'zod'

export const createProjectSchema = z.object({
  name: z.string().min(3).max(255),
  client: z.string().optional(),
  description: z.string().max(1000).optional()
})

export const uploadRCSchema = z.object({
  file: z.custom<File>((v) => v instanceof File && v.type === 'application/pdf')
})

export const generateSchema = z.object({
  selectedMemoires: z.array(z.string().uuid()).min(1).max(5),
  sectionsConfig: z.array(z.object({
    type: z.enum([
      'PRESENTATION_ENTREPRISE',
      'ORGANIGRAMME_GROUPE',
      // ...
    ]),
    enabled: z.boolean(),
    order: z.number().int().positive(),
    customInstructions: z.string().max(500).optional()
  })),
  globalInstructions: z.string().max(1000).optional()
})
```

### 5.2 Rate Limiting

```typescript
// middleware/rate-limit.ts

import rateLimit from 'express-rate-limit'

export const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // max 100 requests par IP
})

export const generationLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 heure
  max: 10 // max 10 générations par heure
})
```

### 5.3 Authentication (NextAuth)

```typescript
// lib/auth.ts

import NextAuth from 'next-auth'
import CredentialsProvider from 'next-auth/providers/credentials'
import { prisma } from '@/lib/prisma'
import bcrypt from 'bcrypt'

export const authOptions = {
  providers: [
    CredentialsProvider({
      credentials: {
        email: { type: 'email' },
        password: { type: 'password' }
      },
      async authorize(credentials) {
        const user = await prisma.user.findUnique({
          where: { email: credentials.email }
        })

        if (!user) return null

        const valid = await bcrypt.compare(
          credentials.password,
          user.passwordHash
        )

        if (!valid) return null

        return { id: user.id, email: user.email, name: user.name }
      }
    })
  ],
  session: { strategy: 'jwt' },
  pages: {
    signIn: '/login'
  }
}
```

---

## 6. Monitoring & Logging

### 6.1 Logging

```typescript
// lib/logger.ts

import pino from 'pino'

export const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport: {
    target: 'pino-pretty',
    options: {
      colorize: true
    }
  }
})

// Usage
logger.info({ projectId, sectionType }, 'Starting section generation')
logger.error({ error, projectId }, 'Generation failed')
```

### 6.2 Métriques

```typescript
// lib/metrics.ts

import { Registry, Counter, Histogram } from 'prom-client'

const register = new Registry()

export const generationCounter = new Counter({
  name: 'memoires_generation_total',
  help: 'Total number of memoires generated',
  labelNames: ['status']
})

export const generationDuration = new Histogram({
  name: 'memoires_generation_duration_seconds',
  help: 'Duration of memoire generation',
  buckets: [10, 30, 60, 120, 300]
})

register.registerMetric(generationCounter)
register.registerMetric(generationDuration)

// Endpoint
app.get('/metrics', async (req, res) => {
  res.set('Content-Type', register.contentType)
  res.end(await register.metrics())
})
```

---

## 7. Tests Backend

### 7.1 Tests unitaires

```typescript
// services/rag/__tests__/rag.service.test.ts

import { describe, it, expect, beforeEach } from 'vitest'
import { RAGService } from '../rag.service'

describe('RAGService', () => {
  let ragService: RAGService

  beforeEach(() => {
    ragService = new RAGService()
  })

  it('should search relevant chunks', async () => {
    const chunks = await ragService.searchRelevantChunks(
      'organisation du chantier',
      ['memoire-1', 'memoire-2'],
      10
    )

    expect(chunks).toHaveLength(10)
    expect(chunks[0]).toHaveProperty('content')
    expect(chunks[0]).toHaveProperty('similarity')
    expect(chunks[0].similarity).toBeGreaterThan(0.7)
  })

  it('should suggest similar memoires', async () => {
    const suggestions = await ragService.suggestSimilarMemoires(
      'Construction de logements collectifs',
      5
    )

    expect(suggestions).toHaveLength(5)
    expect(suggestions[0].similarityScore).toBeGreaterThan(
      suggestions[4].similarityScore
    )
  })
})
```

### 7.2 Tests d'intégration

```typescript
// api/__tests__/projects.test.ts

import { describe, it, expect } from 'vitest'
import request from 'supertest'
import { app } from '@/app'

describe('POST /api/projects', () => {
  it('should create a new project', async () => {
    const response = await request(app)
      .post('/api/projects')
      .send({
        name: 'Test Project',
        client: 'Test Client'
      })
      .expect(201)

    expect(response.body).toHaveProperty('id')
    expect(response.body.name).toBe('Test Project')
    expect(response.body.status).toBe('DRAFT')
  })

  it('should validate project name', async () => {
    const response = await request(app)
      .post('/api/projects')
      .send({ name: 'a' }) // trop court
      .expect(400)

    expect(response.body.error).toContain('min')
  })
})
```

---

## 8. Déploiement

### 8.1 Docker

**Dockerfile (Node.js):**
```dockerfile
FROM node:20-alpine AS base

WORKDIR /app
COPY package*.json ./
RUN npm ci

COPY . .
RUN npm run build

FROM node:20-alpine AS runner
WORKDIR /app

COPY --from=base /app/.next ./.next
COPY --from=base /app/node_modules ./node_modules
COPY --from=base /app/package.json ./package.json

EXPOSE 3000
CMD ["npm", "start"]
```

**Dockerfile (Python):**
```dockerfile
FROM python:3.11-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

**docker-compose.yml:**
```yaml
version: '3.8'

services:
  postgres:
    image: pgvector/pgvector:pg15
    environment:
      POSTGRES_DB: memoires
      POSTGRES_PASSWORD: secret
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  backend:
    build: .
    ports:
      - "3000:3000"
    environment:
      DATABASE_URL: postgresql://postgres:secret@postgres:5432/memoires
      REDIS_URL: redis://redis:6379
      CLAUDE_API_KEY: ${CLAUDE_API_KEY}
      S3_BUCKET: ${S3_BUCKET}
    depends_on:
      - postgres
      - redis

  python-service:
    build: ./python
    ports:
      - "8000:8000"

volumes:
  postgres_data:
```

---

## 9. Variables d'environnement

```env
# Database
DATABASE_URL=postgresql://user:pass@localhost:5432/memoires

# Redis
REDIS_URL=redis://localhost:6379

# AI
CLAUDE_API_KEY=sk-ant-...
OPENAI_API_KEY=sk-...

# Storage
S3_BUCKET=bernadet-memoires
S3_ACCESS_KEY_ID=...
S3_SECRET_ACCESS_KEY=...
S3_REGION=eu-west-3

# Auth
NEXTAUTH_SECRET=...
NEXTAUTH_URL=http://localhost:3000

# Python service
PYTHON_SERVICE_URL=http://localhost:8000

# Misc
NODE_ENV=development
LOG_LEVEL=info
```

---

## 10. Performance & Optimisation

### Caching
- **Redis**: Cache des embeddings fréquemment utilisés
- **React Query**: Cache côté client
- **CDN**: Assets statiques (images, templates)

### Database
- **Indexes**: Sur `projectId`, `memoireId`, `userId`
- **Connection pooling**: Prisma (10 connexions)
- **pgvector indexes**: ivfflat pour recherche rapide

### Rate limits
- Génération: 10/heure par user
- Upload: 50MB max
- API: 100 req/15min par IP

---